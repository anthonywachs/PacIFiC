/**
# Damien's sandbox
## Overview
<img style = float:right src="images/rbc_lvl9.png" alt="RBC" width="240px"/>

Welcome to my sandbox. Here, I provide documentation, test cases and references related to the implementation of immersed elastic capsules - such as red blood cells - in a wide range of Reynolds numbers.

## Lagrangian framework
In the Lagrangian description, also referred to as _front-tracking method_, we
follow the membrane using an unstructured mesh, which we use to compute the
internal strains and stresses of the membrane. These stresses are transferred to
the fluid with the Immersed Boundary Method (IBM), i.e. by means of a
regularized Dirac function as introduced by Peskin. The present Lagrangian
implementation is implemented in two and three dimensions. More information about the development of this approach can be found in this [preprint](https://arxiv.org/abs/2211.15814).

#### Source files
* [lag-mesh.h](src/lagrangian_caps/lag-mesh.h): definition of the mesh,
computation of geometrical quantities, advection of the mesh.
* [lag-mesh-mpi.h](src/lagrangian_caps/lag-mesh-mpi.h): helper functions
for compatibility with MPI
* [mesh-toolbox.h](src/lagrangian_caps/mesh-toolbox.h): helper functions for
Lagrangian meshes: mainly for creating 3D meshed surfaces, but also to create
restart files, and soon Paraview visualization of the membranes.
* [reg-dirac.h](src/lagrangian_caps/reg-dirac.h): Implementation of the immersed
boundary method. Because we use the Cache structures, the code in this sandbox
is only compatible with quadtree and octree grids.
* [elasticity-ft.h](src/lagrangian_caps/elasticity-ft.h): Implementation of the
membrane elasticity in the front-tracking framework. In 3D, this is an explicit
finite element method.
* [neo-hookean.h](src/lagrangian_caps/neo-hookean.h): Implementation of the
neo-Hookean elatic law.
* [skalak.h](src/lagrangian_caps/skalak.h): Implementation of the
Skalak elatic law, describing lipid-bilayer biological membranes.
* [higer-order-neo-hookean.h](src/lagrangian_caps/ho-neo-hookean.h):
Implementation of the higher-order neo-Hookean elastic force, for extreme
deformation of red blood cells.
* [bending-ft.h](src/lagrangian_caps/bending-ft.h): Implementation of a bending
force (in 3D only, the 2D implementation is located [here](src/lagrangian_caps/bending-2d.c) but it failed validation).
* [curvature-ft.h](src/lagrangian_caps/curvature-ft.h): Implementation of the
nodal curvature computations for 2D and 3D membranes, by fitting polynomial to
the nearest neighbors (and using the ordinary least-squares method in 3D).
* [caps-viscosity.h](src/lagrangian_caps/caps-viscosity.h): Allows non-unity
viscosity ratios between the fluids inner and outer to the capsule. Based on the
method of Tryggvason et al.
* [view-ft.h](src/lagrangian_caps/view-ft.h): Allows visualization of the
Lagrangian mesh using bview.
* [common-shapes.h](src/lagrangian_caps/common-shapes.h): Some pre-defined
initial shapes for the capsules.
* [matrix-toolbox](src/lagrangian_caps/matrix-toolbox.h): An implementation in
C of the inversion of matrices using LU-decomposition, copy-pasted entirely
from this
[Wikipedia page](https://en.wikipedia.org/wiki/LU_decomposition#C_code_example).
* [linear_elasticity.h](src/lagrangian_caps/linear-elasticity.h): Implementation
of a linear elastic law, useful only for comparison with some papers from
Pozrikidis.

#### Validation cases
* [advect_caps.c](tests/lagrangian_caps/advect_caps.c): tests the simple advection
of a capsule devoid of elasticity.
* [curvature.c](tests/lagrangian_caps/curvature.c): tests the computations of
the normal vectors and curvature of a capsule in 2 dimensions.
* [uniaxial_stretch.c](tests/lagrangian_caps/uniaxial_stretch.c): tests the
computation of 3D elastic tensions for a flat membrane, for both the
neo-Hookean and Skalak laws.
* [biconcave_curvatures.c](tests/lagrangian_caps/biconcave_curvatures.c) tests
the computations of the mean, Gaussian, surface Laplacian and total Helfrich's
bending force on a 3D biconcave membrane in the absence of reference curvature.
* [nh_shear.c](tests/lagrangian_caps/nh_shear.c): tests the general
3D implementation, including the neo-Hookean elastic law, and compares the
result to various authors.
* [bending_shear.c](tests/lagrangian_caps/bending_shear.c): same test as
[nh_shear.c](tests/lagrangian_caps/nh_shear.c) with the addition of a bending
stress. Results are compared to various authors.
* [rbc_shear.c](tests/lagrangian_caps/rbc_shear.c): Red blood cell (RBC) in a shear flow. Qualitative comparison with a Yazdani \& Bagchi.
* [constricted_channel.c](tests/lagrangian_caps/constricted_channel.c): tests
the Skalak elasticty law, the interaction with embedded boundaries and compares
quantitatively the deformation of the capsule to that of Park \&
Dimitrakopoulos.
* [caps_interception.c](tests/lagrangian_caps/caps_interception.c): tests the
interaction of two elastic capsules, and compares to the work of Lu and
Barth√®s-Biesel, JFM, 2007.
* [caps_interception_inertia.c](tests/lagrangian_caps/caps_interception_inertia.c):
tests the interaction of two elastic capsules in the presence of inerta
($Re = 3, 10, 50$), and compares to the work of Doddi \& Bagchi (2008).

#### Original results
<!---* [narrow_constricted_channel.c](tests/lagrangian_caps/narrow_constricted_channel.c):
same case as [constricted_channel.c](tests/lagrangian_caps/constricted_channel.c) but with a narrower constriction size, a finer grid
resolution, and the addition of bending effects.-->
* [helix.c](cases/lagrangian_caps/helix.c): a demonstration case in a large 3D
domain featuring a helicoidal channel. Inertial migration of a capsule is
observed for $Re = 10, 50$.
* [caps_corner.c](cases/lagrangian_caps/caps_corner.c): an extensive parametric  study of the deformation of interacting capsules in a sharp corner in the presence of inertia.

#### Limitations and known bugs
* The 2D bending force currently leads to numerical instabilities, probably due
to a wrong understanding of the force formulation on my part. The 3D version is
working and well validated, however.
* Multigrid: since the Cache structure is used in the IBM implementation, the
code on this sandbox is compatible with quad/octree grids but not Cartesian or
multigrid.
* Visualization tools: visualizing the edges of the mesh in 3D is necessary to
get some visual perspective because the textures on triangular faces (i.e. the
shades) have not been implemented.

#### To do list
* **Better MPI parallelism**: right now there is only one MPI communication per time step during the interpolation of the velocity from the octree grid to the membrane nodes (two if the RK2 scheme is used), but it comes at the price of having every processor compute the motion of every node of every capsule. This is highly inefficient and could be made better by (i) using "bounding boxes" for our capsules, such that only processors that deal with fuid cells close to a capsule see it; or (ii) implement our surface triangulation locally on grid cells one the `scalar` quantity allows to consider `struct` rather than `double` (in this case we would have a scalar that is an array of arrays of nodes, edges and triangles).
* **Shading effect in bview**: right now the triangles are outputted in bview in plain white color, so it is necessary to draw the edges in order to get the impression of 3D.
* **Compatibility with multigrid**: because our Lagrangian stencils are stored in `Cache` structures, the code is only compatible with tree grids. If we want to study non adaptive cases, i.e. a constant level of refinement everywhere, using multigrids is more efficient and the code could be made compatible with it by not relying on Caches and using a more efficient way to access the cells in the stencil thant the `locate()` function.
* **Elegant volume conservation correction**: we could use the approach of Mendez et al., JCP, 2014 to impose a constant volume of the capsules by solving a (simple) optimization problem. It performs better than simply pulling on the nodes in the normal direction, and can be seen as a correction for the non-conservativity of the velocity interpolation of the IBM.
* **Stencils spanning cells of variable levels**: it can be useful in some selected configurations, and could be performed by requiring the stencils to remain isotropic and simply averaging of the velocity/force. If this approach is too naive, I don't see why yet.
* **More efficient computation of indicator function**: this is useful only if we consider a viscosity ratio inside/outside of the capsules. In this case, we can tweak the Poisson solver to only iterate through the cells located close to the membrane, because we know that the indicator function away from the membrane will remain constant.
* **Output capsules in Paraview in binary files**: requires to find a good documentation of the Paraview file format.
* **Wall-aware IBM stencils**: renormalize the convolution operations in the IBM when some cells of the stencil are located outside of the fluid domain.
* **Predefined output functions**: provide the code user with functions to output typical quantities such as capsule centroids, average and maximum stress, etc.



## Eulerian framework
In the Eulerian framework, we do not mesh the capsules. The source files
below aimed at reproducing and improving the method of Ii et al (2012, 2018).
However, they did not lead to quantitatively satisfactory results and this
approach has been abandoned for now.

The Eulerian approach uses the VOF framework provided by Basilisk to track the position of the membrane. It has the main advantage of requiring only one common mesh for the background fluid and the capsules, thus greatly simplifying the implementation when adaptive mesh refinement (AMR) is considered. We can expect that for a large number of capsules, such an Eulerian description provides better computational performances than the Lagrangian alternative representation. Quantifying this improvement would have been one of the sub-goals of this study.

Obviously, this Eulerian approach comes with downsides too:

* The membrane representation is not sharp, as the Eulerian quantity describing the membrane stretches (the surface left Cauchy-Green deformation tensor) need to be defined in a region of space of typical width 5 to 7 grid cells.
* When the Eulerian quantities are advected, diffusion will imply that the membrane "forgets" parts of its initial, unstressed configuration. As such, great care has to be taken to minimize diffusion in the advection step.
* Representing the membrane stresses on the Eulerian grid might present more
stability issues than using a Lagrangian mesh + immersed boundary method
approach, although this is only speculation at this point.


#### Source files
* [capsule.h](src/eulerian_caps/capsule.h): definition of the membrane region by smoothing the VOF function, application of the body-force from the membrane to the fluid.
* [elasticity.h](src/eulerian_caps/elasticity.h): definition, advection and projection of the (modified) surface left Cauchy-Green deformation tensor $\mathbf{G}$ and the surface Jacobian $J$.
* [neo_hookean.h](src/eulerian_caps/neo-hookean.h): computation of the elastic stress for a Neo-Hookean membrane using $\mathbf{G}$, $J$ and the projector onto the membrane surface $\mathbf{P}$.
* [normal_extension.h](src/eulerian_caps/normal_extension.h): extension of scalar quantities defined in interfacial cells to the extended membrane region along the normal direction, using a Hamilton-Jacobi equation. Also, extension of normal vectors themselves.
* [navier-stokes/my_centered.h](src/navier-stokes/my_centered.h): same as navier-stokes/centered.h, with addition of the *pp_vof* event (standing for "post-processing VOF") onto which capsule.h can hook.
* [grid/\*.h](src/grid): Modification of cartesian_commons.h in order to allow the definition of 3D tensors. All the other .h files in this folder need to point to the new cartesian_commons.h.


#### Test cases
* constant_elongation.h: (not uploaded yet) tests the computation of the source terms of the advection equations for $J$ and $\mathbf{G}$, as well as the computation of the stress tensor.
* linear_elongation.h: (not uploaded yet) tests the full advection equation for $J$ and $\mathbf{G}$, since the gradient terms are non zero. Also tests the computation of the acceleration.
* normal_scalar_extension.h: (not uploaded yet) tests the extension of a scalar quantity from the interfactial cells to the rest of the extended membrane region along the normals.
* normal_vector_extension.h: (not uploaded yet) tests the extension of normal vectors themselves from the interfacial cells to the rest of the membrane region.


#### Known bugs
* __It never reproduced quantitatively acceptable results__. Don't use these Eulerian source files unless you want to fix the implementation/the method yourself.
* The normal vectors provided *on* the interface by the height functions are assumed to be provided at the center of the interfacial cells by the current implementation.
* Default boundary conditions of 3D tensors are not defined. This is fine as long as the developers/users are aware of it.

*/
