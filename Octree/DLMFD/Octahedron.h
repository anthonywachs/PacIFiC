/** 
# Set of functions for a octahedron 
*/


//----------------------------------------------------------------------------
int determ_posi_plane_Octahedron( coord* pointOne, coord* pointTwo, 
	coord* pointThree, coord* pointCheck )
//----------------------------------------------------------------------------	 
{
  // Equation of the plane: ax + by + cz + k = 0
  double x1 = pointOne->x;
  double y1 = pointOne->y;
  double z1 = pointOne->z;	
  double x2 = pointTwo->x;
  double y2 = pointTwo->y;
  double z2 = pointTwo->z;
  double x3 = pointThree->x;
  double y3 = pointThree->y;
  double z3 = pointThree->z;
	
  double xc = pointCheck->x;
  double yc = pointCheck->y;
  double zc = pointCheck->z;

  double cross_a = (y2 - y1) * (z3 - z2) - (z2 - z1) * (y3 - y2);
  double cross_b = (z2 - z1) * (x3 - x2) - (x2 - x1) * (z3 - z2);
  double cross_c = (x2 - x1) * (y3 - y2) - (y2 - y1) * (x3 - x2);

  double k =  - (cross_a*x1 + cross_b*y1 + cross_c*z1);

  double check_value  = cross_a*xc + cross_b*yc + cross_c*zc + k;

  int retVal;
  if ( fabs(check_value) > 1.e-13 )
    retVal = (k*check_value > 0) - (k*check_value < 0); 
  else 
    retVal = 0;

  return retVal;  
}




/** Tests whether a point lies inside the octahedron */
//----------------------------------------------------------------------------
bool is_in_Octahedron( const double x, const double y, const double z, 
	const GeomParameter gp )
//----------------------------------------------------------------------------
{
  GeomParameter const* gcp = &gp;
         
  coord checkpt;
  checkpt.x = x - gcp->center.x;
  checkpt.y = y - gcp->center.y;
  checkpt.z = z - gcp->center.z;

  int nfaces = gcp->pgp->allFaces;
  int iref, i1, i2, ichoice;

  ichoice = 0;
  int npoints;

  int* position = (int *) calloc( nfaces, sizeof(int) );
  
  for (int i = 0; i < nfaces; i++) 
  {
    npoints = gcp->pgp->numPointsOnFaces[i];
  
    iref = gcp->pgp->cornersIndex[i][ichoice];
    i1 = gcp->pgp->cornersIndex[i][ichoice + 1];
    i2 = gcp->pgp->cornersIndex[i][npoints - 1];

    coord refcorner = {gcp->pgp->cornersCoord[iref][0] - gcp->center.x, 
    	gcp->pgp->cornersCoord[iref][1] - gcp->center.y,
    	gcp->pgp->cornersCoord[iref][2] - gcp->center.z}; 

    coord cornerTwo = {gcp->pgp->cornersCoord[i1][0] - gcp->center.x, 
    	gcp->pgp->cornersCoord[i1][1] - gcp->center.y,
    	gcp->pgp->cornersCoord[i1][2] - gcp->center.z};

    coord cornerThree = {gcp->pgp->cornersCoord[i2][0] - gcp->center.x, 
    	gcp->pgp->cornersCoord[i2][1] - gcp->center.y,
    	gcp->pgp->cornersCoord[i2][2] - gcp->center.z};

    // Judge if the point lies at the same side with origin 
    // compared to the plane generated by refcorner, cornerTwo
    // and cornerThree
    position[i]  = determ_posi_plane_Octahedron( &refcorner, &cornerTwo, 
	        &cornerThree, &checkpt );
  }

  bool isin=false;
  int all_position = 0;
  for(int i = 0; i < nfaces; i++) all_position += position[i] ;  
  
  if ( all_position == nfaces ) isin = true;

  free( position );

  return isin;
}


/** Computes the number of boundary points on the surface of the octahedron */
//----------------------------------------------------------------------------
void compute_nboundary_Octahedron( GeomParameter* gcp, int* nb, int* lN ) 
//----------------------------------------------------------------------------
{
  Cache poscache = {0};
  Point lpoint;
  *nb = 0;
  coord pos = {0., 0., 0.};
  int ip = 0;

  while ( *nb == 0 ) 
  {
    pos.x = gcp->pgp->cornersCoord[ip][0];
    pos.y = gcp->pgp->cornersCoord[ip][1];
    pos.z = gcp->pgp->cornersCoord[ip][2];
    lpoint = locate( pos.x, pos.y, pos.z );
   
    /** Only one thread has the point in its domain (works in serial
	too). */
    if ( lpoint.level > -1 ) 
    {    
      /** Only this thread creates the Cache ... */
      cache_append(&poscache, lpoint, 0); 

      /** and only this thread computes the number of boundary points
	  ... */
    
      /* Grains sends the octahedron circumscribed radius, so to get the 
      octahedron edge length we multiply by sqrt(2.) */ 
      double lengthedge = gcp->radius * sqrt (2.) ;
    
      /* We compute the number of intervals on the octahedron edge */             
      foreach_cache (poscache) 
      {
	*lN = floor( lengthedge / ( INTERBPCOEF * Delta ) );
	
        /* The numberof points on a octahedron edge is the number of 
	intervals + 1 */
        *lN += 1;      
      }
      
      /* number of points required for the 12 edges of the octahedron */
      *nb += (*lN-2) * 12;
      /* number of points required for the 8 faces of the octahedron */
      *nb += 8 *(*lN-2)*(*lN-3)/2.;
      /* number of points required for the 6 corners of the octahedron */
      *nb += 6;
      
      /** and finally, this thread destroys the cache. */
      free( poscache.p );
    }
  
#   if _MPI
      MPI_Barrier( MPI_COMM_WORLD );
      mpi_all_reduce( *nb, MPI_INT, MPI_MAX );
      mpi_all_reduce( *lN, MPI_INT, MPI_MAX );
#   endif
    
    if ( ip < gcp->ncorners )
      ip++;
    else
      break;
  }
  
  if ( *nb == 0 )
    fprintf( stderr,"nboundary = 0: No boundary points for the"
    	" Octahedron !!!\n" );
}




/** Distributes points on an edge of the octahedron */
//----------------------------------------------------------------------------
void distribute_points_edge_Octahedron( coord const corner1, 
	coord const corner2, SolidBodyBoundary* dlm_bd, 
	int const lN, int const istart ) 
//----------------------------------------------------------------------------
{
  if ( lN > 0 ) 
  {
    coord dinc; 

    foreach_dimension()
      dinc.x = (corner2.x - corner1.x)/(lN-1);

    for (int i = 1; i <= lN-2; i++) 
    {
      dlm_bd->x[istart + i -1] = corner1.x + (double)i * dinc.x; 
      dlm_bd->y[istart + i -1] = corner1.y + (double)i * dinc.y;
      dlm_bd->z[istart + i -1] = corner1.z + (double)i * dinc.z;
    }
  }
}




/** Creates boundary points on the surface of the octahedron */
//----------------------------------------------------------------------------
void create_FD_Boundary_Octahedron( GeomParameter* gcp, 
	SolidBodyBoundary* dlm_bd, const int m, const int lN, vector pshift ) 
//----------------------------------------------------------------------------
{
  int nfaces = gcp->pgp->allFaces;
  int iref, i1, i2, ichoice;

  ichoice = 0;
  int isb = 0;
  int npoints;

  /* Add first interrior points on surfaces */
  for (int i = 0; i < nfaces; i++) 
  {
    npoints = gcp->pgp->numPointsOnFaces[i];
    
    iref = gcp->pgp->cornersIndex[i][ichoice];
    i1 = gcp->pgp->cornersIndex[i][ichoice + 1];
    i2 = gcp->pgp->cornersIndex[i][npoints-1];

    coord refcorner = {gcp->pgp->cornersCoord[iref][0], 
    	gcp->pgp->cornersCoord[iref][1],
    	gcp->pgp->cornersCoord[iref][2]} ; 

    coord dir1 = {gcp->pgp->cornersCoord[i1][0], 
    	gcp->pgp->cornersCoord[i1][1],
    	gcp->pgp->cornersCoord[i1][2]};

    coord dir2 = {gcp->pgp->cornersCoord[i2][0], 
    	gcp->pgp->cornersCoord[i2][1],
    	gcp->pgp->cornersCoord[i2][2]};
    
    foreach_dimension() 
    {
      dir1.x -= refcorner.x;
      dir2.x -= refcorner.x;
      dir1.x /= (lN-1);
      dir2.x /= (lN-1);
    }
       
    for (int ii = 1; ii <= lN-2; ii++) 
    {
      for (int jj = 1; jj <= lN-2 - ii; jj++) 
      { 
	dlm_bd->x[isb] = refcorner.x + (double) ii * dir1.x 
		+ (double) jj * dir2.x;

	dlm_bd->y[isb] = refcorner.y + (double) ii * dir1.y 
		+ (double) jj * dir2.y;

	dlm_bd->z[isb] = refcorner.z + (double) ii * dir1.z 
		+ (double) jj * dir2.z;
	isb++;
      }
    }
  }

  // We have 6 corner points for the octahedron
  int allindextable[6][6] = {{0}};
  int j1, jm1;
  
  /* Add points on the edges without the corners*/
  for (int i = 0; i < nfaces; i++) 
  {
    npoints = gcp->pgp->numPointsOnFaces[i];
    i1 = gcp->pgp->cornersIndex[i][1];

    for (int j = 1; j < npoints; j++) 
    {
      jm1 = gcp->pgp->cornersIndex[i][j-1];
      j1 = gcp->pgp->cornersIndex[i][j];
      
      if ( jm1 > j1 ) 
      {
	if ( allindextable[jm1][j1] == 0 ) 
	{
	  coord c1 = {gcp->pgp->cornersCoord[jm1][0], 
	  	gcp->pgp->cornersCoord[jm1][1], 
	  	gcp->pgp->cornersCoord[jm1][2]};
	  coord c2 = {gcp->pgp->cornersCoord[j1][0], 
	  	gcp->pgp->cornersCoord[j1][1], 
	  	gcp->pgp->cornersCoord[j1][2]};
	  distribute_points_edge_Octahedron( c1, c2, dlm_bd, lN, isb );
	  allindextable[jm1][j1] = 1;
	  isb +=lN-2;
	}
      }      
      else 
      {
	if ( allindextable[j1][jm1] == 0 ) 
	{
	  coord c1 = {gcp->pgp->cornersCoord[j1][0], 
	  	gcp->pgp->cornersCoord[j1][1], 
	  	gcp->pgp->cornersCoord[j1][2]};
	  coord c2 = {gcp->pgp->cornersCoord[jm1][0], 
	  	gcp->pgp->cornersCoord[jm1][1], 
	  	gcp->pgp->cornersCoord[jm1][2]};
	  distribute_points_edge_Octahedron( c1, c2, dlm_bd, lN, isb );
	  allindextable[j1][jm1] = 1;
	  isb +=lN-2;
	}
      }
    }   
  }
  
  /* Add the final 6 corners points */
  for (int i = 0; i  < gcp->ncorners; i++) 
  {
    dlm_bd->x[isb] = gcp->pgp->cornersCoord[i][0];
    dlm_bd->y[isb] = gcp->pgp->cornersCoord[i][1];
    dlm_bd->z[isb] = gcp->pgp->cornersCoord[i][2];
    isb++;
  }


}




/** Finds cells lying inside the octahedron */
//----------------------------------------------------------------------------
void create_FD_Interior_Octahedron( particle * p, vector Index_lambda, 
	vector shift ) 
//----------------------------------------------------------------------------
{
  Cache* c;
  
  /** Create the cache of the interior points for a octahedron*/
  c = &(p->Interior);

  /** Extract geometric information from particle pointer p */
  GeomParameter gp = p->g;

  /* Min/Max coordinates for the AABB (Axed-Aligned-Bounding-Box) */
  coord mincoord = {HUGE, HUGE, HUGE};
  coord maxcoord = {-HUGE, -HUGE, -HUGE};

  double ** table = p->g.pgp->cornersCoord;
  for (int ii = 0; ii < p->g.ncorners; ii++) 
  {
    if (mincoord.x > table[ii][0])
      mincoord.x = table[ii][0];

    if (mincoord.y > table[ii][1])
      mincoord.y = table[ii][1];

    if (mincoord.z > table[ii][2])
      mincoord.z = table[ii][2];

    if (maxcoord.x < table[ii][0])
      maxcoord.x = table[ii][0];

    if (maxcoord.y < table[ii][1])
      maxcoord.y = table[ii][1];

    if (maxcoord.z < table[ii][2])
      maxcoord.z = table[ii][2];
  }

  foreach() 
  {
    coord checkpt;    
    checkpt.x = x;
    checkpt.y = y;
    checkpt.z = z;

    /* Check only if the point is in the AABB (Axed-Aligned-Bounding-Box) */
    if ( ( x > mincoord.x ) && ( x < maxcoord.x ) ) 
      if ( ( y > mincoord.y ) && ( y < maxcoord.y ) )
	if ( ( z > mincoord.z ) && ( z < maxcoord.z ) )

	  /* If yes: check if it is inside the octahedron now */
    	  if ( is_in_Octahedron( checkpt.x, checkpt.y, checkpt.z, gp ) ) 
	  {
	    cache_append( c, point, 0 );
	    /* tag cell with the number of the particle */
	    if ( (int)Index_lambda.y[] == -1 )
	      Index_lambda.y[] = p->pnum;
	  }
  }
  
  cache_shrink( c );
}




/** Reads geometric parameters of the octahedron */
//----------------------------------------------------------------------------
void update_Octahedron( GeomParameter* gcp ) 
//----------------------------------------------------------------------------
{  
  char* token = NULL;

  // Read number of corners, check that it is 6
  size_t nc = 0;
  token = strtok(NULL, " " );
  sscanf( token, "%lu", &nc );
  if ( nc != 6 )
    printf ("Error in number of corners in update_Octahedron \n");

  // Allocate the PolyGeomParameter structure
  gcp->pgp = (PolyGeomParameter*) malloc( sizeof(PolyGeomParameter) );
  gcp->pgp->allPoints = nc;

  // Allocate the array of corner coordinates
  gcp->pgp->cornersCoord = (double**) malloc( nc * sizeof(double*) );
  for (size_t i=0;i<nc;i++)
    gcp->pgp->cornersCoord[i] = (double*) malloc( 3 * sizeof(double) );

  // Read the point/corner coordinates
  for (size_t i=0;i<nc;++i)
    for (size_t j=0;j<3;++j)
    {
      token = strtok(NULL, " " );
      sscanf( token, "%lf", &(gcp->pgp->cornersCoord[i][j]) );
    }

  // Read number of faces, check that it is 8
  size_t nf = 0;
  token = strtok(NULL, " " );
  sscanf( token, "%lu", &nf );
  if ( nf != 8 )
    printf ("Error in number of faces in update_Octahedron\n");
  gcp->pgp->allFaces = nf;

  // Allocate the array of number of points/corners on each face
  gcp->pgp->numPointsOnFaces = (long int*) malloc( nf * sizeof(long int) );

  // Allocate the array of point/corner indices on each face
  gcp->pgp->cornersIndex = (long int**) malloc( nf * sizeof(long int*) );

  // Read the face indices
  long int nppf = 0;
  for (size_t i=0;i<nf;++i)
  {
    // Read the number of points/corners on the face, check that it is 3
    token = strtok(NULL, " " );
    sscanf( token, "%ld", &nppf );
    if ( nppf != 3 )
      printf ("Error in number of corners per face in update_Octahedron\n");
    gcp->pgp->numPointsOnFaces[i] = nppf;

    // Allocate the point/corner index vector on the face
    gcp->pgp->cornersIndex[i] = (long int*) malloc( nppf * sizeof(long int) );

    // Read the point/corner indices
    for (size_t j=0;j<3;++j)
    {
      token = strtok(NULL, " " );
      sscanf( token, "%ld", &(gcp->pgp->cornersIndex[i][j]));
    }
  }
	
}




/** Frees the geometric parameters of the octahedron */
//----------------------------------------------------------------------------
void free_Octahedron( GeomParameter* gcp ) 
//----------------------------------------------------------------------------
{  
  // Free the point/corner coordinate array
  double* cc = NULL;
  for (int i=0; i < gcp->pgp->allPoints; ++i) 
  {
    cc = &(gcp->pgp->cornersCoord[i][0]);
    free( cc );
    cc = NULL;
  }
  free( gcp->pgp->cornersCoord );
  gcp->pgp->cornersCoord = NULL;
  gcp->pgp->allPoints = 0;

  // Free the point/corner arrays
  long int* in = NULL;
  for (int i=0;i < gcp->pgp->allFaces; ++i) 
  {
    in = &(gcp->pgp->cornersIndex[i][0]);   
    free( in );
    in = NULL;
  }
  free( gcp->pgp->cornersIndex );
  gcp->pgp->cornersIndex = NULL;
  free( gcp->pgp->numPointsOnFaces );
  gcp->pgp->numPointsOnFaces = NULL;
  gcp->pgp->allFaces = 0;
  
  // Free the PolyGeomParameter structure
  free( gcp->pgp );
  gcp->pgp = NULL;
}
